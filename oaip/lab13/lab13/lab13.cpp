// Небольшая преамбула, получается. В данном допе у нас есть два режима хеширования: универсальное и модульное
// В файле "Source.cpp" у нас есть функция HashFunction (9 строка). Там я указал, какая функция за какой режим хеширования отвечает
// Остальное вроде как должно быть понятным, но если что-то непонятно - пиши)
// Классно совпало, кстати. Этот доп - вся моя 13-ая лабораторная пхпх. Поэтому качество лабы должно быть хорошим, раз я её сдал

#include "Header.h" // Подключение пользовательского заголовочного файла
#include <iostream> // Подключение стандартной библиотеки ввода-вывода
#include <ctime> // Подключение стандартной библиотеки для работы со временем
#include <vector> // Подключение стандартной библиотеки для работы с векторами
#include <algorithm> // Подключение стандартной библиотеки для работы с алгоритмами

using namespace std; // Использование пространства имен std

// Структура AAA
struct AAA
{
    int key; // Ключ
    char* mas; // Строка
    AAA(int k, char* z) // Конструктор
    {
        key = k; // Инициализация ключа
        mas = z; // Инициализация строки
    }
    AAA() {} // Конструктор по умолчанию
};

// Функция получения ключа из объекта AAA
int key(void* d)
{
    AAA* f = (AAA*)d; // Преобразование указателя к типу AAA
    return f->key; // Возвращение ключа
}

// Функция печати объекта AAA
void AAA_print(void* d)
{
    cout << " ключ " << ((AAA*)d)->key << " - " << ((AAA*)d)->mas << endl; // Вывод ключа и строки
}

// Основная функция программы
int main()
{
    setlocale(LC_ALL, "rus"); // Установка локали для вывода русского текста

    // Создание объектов AAA
    AAA a1(1, (char*)"one"), a2(2, (char*)"two"), a3(4, (char*)"three"), a4(2, (char*)"fo");
    int siz = 7, siz2, choice, k; // Инициализация переменных

    cout << "Введите размер хеш-таблицы 1" << endl; // Вывод приглашения на ввод размера хэш-таблицы 1
    cin >> siz; // Ввод размера хэш-таблицы 1

    cout << "Введите размер хеш-таблицы 2" << endl; // Вывод приглашения на ввод размера хэш-таблицы 2
    cin >> siz2; // Ввод размера хэш-таблицы 2

    Object H = create(siz, key); // Создание объекта H (универсальное хеширование)
    Object G = create(siz2, key); // Создание объекта G (модульное хеширование)

    vector<int> keys1; // Вектор для хранения ключей таблицы 1
    vector<int> keys2; // Вектор для хранения ключей таблицы 2

    // Бесконечный цикл для работы с меню
    for (;;)
    {
        cout << "1 - вывод хеш-таблицы" << endl; // Вывод опции вывода хэш-таблицы
        cout << "2 - добавление элемента" << endl; // Вывод опции добавления элемента
        cout << "3 - удаление элемента" << endl; // Вывод опции удаления элемента
        cout << "4 - поиск элемента" << endl; // Вывод опции поиска элемента
        cout << "5 - вывод хеш-таблицы 2" << endl; // Вывод опции вывода хэш-таблицы 2
        cout << "6 - добавление элемента 2" << endl; // Вывод опции добавления элемента 2
        cout << "7 - удаление элемента 2" << endl; // Вывод опции удаления элемента 2
        cout << "8 - поиск элемента 2" << endl; // Вывод опции поиска элемента 2
        cout << "9 - сравнение скорости поиска" << endl; // Вывод опции сравнения скорости поиска
        cout << "0 - выход" << endl; // Вывод опции выхода
        cout << "сделайте выбор" << endl; // Приглашение на ввод выбора
        cin >> choice; // Ввод выбора
        switch (choice)
        {
        case 0:  exit(0); // Выход из программы
        case 1: { // Опция вывода хэш-таблицы
            setMode(1); // Установка режима хэширования 1
            H.scan(AAA_print); // Вывод хэш-таблицы
        }  break;
        case 2: { // Опция добавления элемента
            setMode(1); // Установка режима хэширования 1
            AAA* a = new AAA; // Создание объекта AAA
            char* str = new char[40]; // Выделение памяти под строку
            cout << "Введите ключ" << endl; // Приглашение на ввод ключа
            cin >> k; // Ввод ключа
            a->key = k; // Установка ключа
            if (count(keys1.begin(), keys1.end(), k) < 1) // Проверка на уникальность ключа
            {
                cout << "Введите строку" << endl; // Приглашение на ввод строки
                cin.ignore(); // Очистка буфера ввода
                cin.getline(str, 40); // Ввод строки
                a->mas = str; // Установка строки
                if (H.N == H.size)
                    cout << "Таблица заполнена" << endl; // Проверка на заполненность таблицы
                else
                    H.insert(a); // Вставка элемента в таблицу
                keys1.push_back(k); // Добавление ключа в вектор ключей
            }
            else
            {
                cout << "Ключ занят" << endl; // Вывод сообщения о занятом ключе
            }
        } break;
        case 3: { // Опция удаления элемента
            setMode(1); // Установка режима хэширования 1
            cout << "Введите ключ для удаления" << endl; // Приглашение на ввод ключа для удаления
            cin >> k; // Ввод ключа
            for (int i = 0; i < keys1.size(); i++) // Поиск ключа в векторе ключей
            {
                if (keys1[i] == k) // Если ключ найден
                {
                    keys1.erase(keys1.begin() + i); // Удаление ключа из вектора ключей
                }
            }
            H.deleteByKey(k); // Удаление элемента по ключу из хэш-таблицы
        }  break;
        case 4: { // Опция поиска элемента
            setMode(1); // Установка режима хэширования 1
            cout << "Введите ключ для поиска" << endl; // Приглашение на ввод ключа для поиска
            cin >> k; // Ввод ключа
            unsigned int start_time = clock(); // Запуск таймера
            if (count(keys1.begin(), keys1.end(), k) == 0) // Проверка наличия ключа в векторе ключей
                cout << "Элемент не найден" << endl; // Вывод сообщения об отсутствии элемента
            else
                AAA_print(H.search(k)); // Поиск и вывод элемента
            unsigned int end_time = clock(); // Остановка таймера
            unsigned int search_time = end_time - start_time; // Вычисление времени поиска
            cout << "Время поиска " << search_time << " ms" << endl; // Вывод времени поиска
        }  break;
        case 5: // Опция вывода хэш-таблицы 2
            setMode(0); // Установка режима хэширования 0
            G.scan(AAA_print); // Вывод хэш-таблицы 2
            break;
        case 6: { // Опция добавления элемента 2
            setMode(0); // Установка режима хэширования 0
            AAA* a = new AAA; // Создание объекта AAA
            char* str = new char[40]; // Выделение памяти под строку
            cout << "Введите ключ" << endl; // Приглашение на ввод ключа
            cin >> k; // Ввод ключа
            a->key = k; // Установка ключа
            if (count(keys2.begin(), keys2.end(), k) < 1) // Проверка на уникальность ключа
            {
                cout << "Введите строку" << endl; // Приглашение на ввод строки
                cin.ignore(); // Очистка буфера ввода
                cin.getline(str, 40); // Ввод строки
                a->mas = str; // Установка строки
                if (G.N == G.size)
                    cout << "Таблица заполнена" << endl; // Проверка на заполненность таблицы
                else
                    G.insert(a); // Вставка элемента в таблицу
                keys2.push_back(k); // Добавление ключа в вектор ключей
            }
            else
            {
                cout << "Ключ занят" << endl; // Вывод сообщения о занятом ключе
            }
        } break;
        case 7: { // Опция удаления элемента 2
            setMode(0); // Установка режима хэширования 0
            cout << "Введите ключ для удаления" << endl; // Приглашение на ввод ключа для удаления
            cin >> k; // Ввод ключа
            for (int i = 0; i < keys2.size(); i++) // Поиск ключа в векторе ключей
            {
                if (keys2[i] == k) // Если ключ найден
                {
                    keys2.erase(keys2.begin() + i); // Удаление ключа из вектора ключей
                }
            }
            G.deleteByKey(k); // Удаление элемента по ключу из хэш-таблицы
        }  break;
        case 8: { // Опция поиска элемента 2
            setMode(0); // Установка режима хэширования 0
            cout << "Введите ключ для поиска" << endl; // Приглашение на ввод ключа для поиска
            cin >> k; // Ввод ключа
            unsigned int start_time = clock(); // Запуск таймера
            if (count(keys2.begin(), keys2.end(), k) == 0) // Проверка наличия ключа в векторе ключей
                cout << "Элемент не найден" << endl; // Вывод сообщения об отсутствии элемента
            else
                AAA_print(G.searchUnivers(k)); // Поиск и вывод элемента
            unsigned int end_time = clock(); // Остановка таймера
            unsigned int search_time = end_time - start_time; // Вычисление времени поиска
            cout << "Время поиска: " << search_time << " ms" << endl; // Вывод времени поиска
        }  break;
        case 9: { // Опция сравнения скорости поиска
            cout << "Введите ключ для поиска" << endl; // Приглашение на ввод ключа для поиска
            cin >> k; // Ввод ключа
            unsigned int start_time_u = clock(); // Запуск таймера
            if (G.search(k) == NULL) // Поиск элемента в хэш-таблице 2
                cout << "Элемент не найден" << endl; // Вывод сообщения об отсутствии элемента
            else
                AAA_print(G.searchUnivers(k)); // Вывод найденного элемента
            unsigned int end_time_u = clock(); // Остановка таймера
            unsigned int search_time_u = end_time_u - start_time_u; // Вычисление времени поиска в универсальной хэш-таблице
            unsigned int start_time = clock(); // Запуск таймера
            if (H.search(k) == NULL) // Поиск элемента в хэш-таблице 1
                cout << "Элемент не найден" << endl; // Вывод сообщения об отсутствии элемента
            else
                AAA_print(H.search(k)); // Вывод найденного элемента
            unsigned int end_time = clock(); // Остановка таймера
            unsigned int search_time = end_time - start_time; // Вычисление времени поиска в модульной хэш-таблице
            if (search_time > search_time_u) // Сравнение времени поиска
            {
                cout << "module hash faster" << endl; // Вывод сообщения о том, что модульная хэш-таблица быстрее
                cout << "Разница: " << search_time - search_time_u << endl; // Вывод разницы во времени
            }
            else
            {
                cout << "universal hash faster" << endl; // Вывод сообщения о том, что универсальная хэш-таблица быстрее
                cout << "Разница: " << search_time_u - search_time << " ms" << endl; // Вывод разницы во времени
            }
        }break;
        case 10: { // Опция добавления нескольких элементов
            char* str = new char[20]; // Выделение памяти под строку
            cout << "Введите строку" << endl; cin >> str; // Ввод строки
            for (int i = 0; i < siz - 2; i++) // Добавление элементов в обе хэш-таблицы
            {
                AAA* a = new AAA; // Создание объекта AAA
                a->key = i; // Установка ключа
                a->mas = str; // Установка строки
                if (H.N == H.size) // Проверка на заполненность таблицы 1
                    cout << "Таблица заполнена" << endl; // Вывод сообщения о заполненности таблицы
                else
                    H.insert(a); // Вставка элемента в таблицу 1
                G.insert(a); // Вставка элемента в таблицу 2
            }
        }break;
        }
    }
    return 0; // Возвращение нуля из функции main
}
