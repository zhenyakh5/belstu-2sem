#include "Header.h" // Подключение пользовательского заголовочного файла
#include <iostream> // Подключение стандартной библиотеки ввода-вывода
#include <cstdlib> // Подключение стандартной библиотеки для функций обработки строк и памяти
#include <ctime> // Подключение стандартной библиотеки для работы со временем

int mode = 0; // Глобальная переменная, определяющая режим хэширования

// Функция хэширования
int HashFunction(int key, int size) {
	if (mode == 1) { // Если установлен режим 1, то у нас будет УНИВЕРСАЛЬНОЕ ХЕШИРОВАНИЕ
		int h = 0, a = 29, b = 13; // Инициализация переменных для хэш-функции
		h = (a * key + b) % size; // Вычисление хэша
		return (h < 0) ? (h + size) : h; // Возвращение хэша
	}
	return key % size; // Возврат остатка от деления ключа на размер хэш-таблицы (МОДУЛЬНОЕ ХЕШИРОВАНИЕ)
}

// Функция определения следующего хэша
int Next_hash(int hash, int size, int p) {
	return (hash + 5 * p + 3 * p * p) % size; // Вычисление следующего хэша
}

// Функция установки режима хэширования
void setMode(int modeId) {
	mode = modeId; // Установка режима хэширования
}

// Создание объекта
Object create(int size, int(*getkey)(void*)) {
	return *(new Object(size, getkey)); // Создание и возвращение объекта
}

// Конструктор объекта
Object::Object(int size, int(*getkey)(void*)) {
	N = 0; // Инициализация количества элементов
	this->size = size; // Установка размера хэш-таблицы
	this->getKey = getkey; // Установка функции получения ключа
	this->data = new void* [size]; // Выделение памяти под данные
	for (int i = 0; i < size; ++i)
		data[i] = NULL; // Инициализация каждого элемента NULL
}

// Функция вставки элемента в хэш-таблицу
bool Object::insert(void* d) {
	bool b = false; // Флаг успешности вставки
	if (N != size) { // Если в таблице есть место
		int key = getKey(d); // Получаем ключ элемента
		int hash = HashFunction(key, size); // Вычисляем хэш ключа
		for (int i = 0, j = hash; i != size && !b; ++i, j = Next_hash(j, size, i)) {
			if (data[j] == NULL || data[j] == DEL) { // Если ячейка пуста или удалена
				data[j] = d; // Вставляем элемент
				N++; // Увеличиваем количество элементов
				b = true; // Устанавливаем флаг успешной вставки
				std::cout << "hash = " << hash << '\n'; // Выводим информацию о хэше
			}
		}
	}
	return b; // Возвращаем результат вставки
}

// Функция поиска индекса элемента в хэш-таблице
int Object::searchInd(int key) {
    int t = -1; // Инициализация индекса элемента
    bool b = false; // Флаг успешного поиска
    if (N != 0) { // Если таблица не пуста
        for (int i = 0, j = HashFunction(key, size); data[j] != NULL && i != size && !b; ++i, j = Next_hash(j, size, i)) {
            if (data[j] != DEL && getKey(data[j]) == key) { // Если ключи совпадают
                t = j; // Запоминаем индекс элемента
                b = true; // Устанавливаем флаг успешного поиска
                std::cout << "hash = " << j << '\n'; // Выводим информацию о хэше
            }
        }
    }
    return t; // Возвращаем индекс элемента
}

// Функция поиска элемента в хэш-таблице
void* Object::search(int key) {
	int t = searchInd(key); // Ищем индекс элемента
	return (t >= 0) ? (data[t]) : (NULL); // Возвращаем элемент, если найден, иначе NULL
}

// Функция универсального поиска элемента в хэш-таблице
void* Object::searchUnivers(int key) {
	srand(time(NULL)); // Инициализация генератора случайных чисел
	int a = rand(); // Генерация случайного числа
	int b = rand(); // Генерация случайного числа
	int t = searchInd(key); // Ищем индекс элемента
	return (t >= 0) ? (data[t]) : (NULL); // Возвращаем элемент, если найден, иначе NULL
}

// Функция удаления элемента из хэш-таблицы по ключу
void* Object::deleteByKey(int key) {
	int i = searchInd(key); // Ищем индекс элемента
	void* t = data[i]; // Запоминаем удаляемый элемент
	if (t != NULL) { // Если элемент найден
		data[i] = DEL; // Помечаем его как удаленный
		N--; // Уменьшаем количество элементов
	}
	return t; // Возвращаем удаленный элемент
}

// Функция удаления элемента из хэш-таблицы по значению
bool Object::deleteByValue(void* d) {
	return (deleteByKey(getKey(d)) != NULL); // Удаляем элемент по ключу, возвращаем результат операции
}

// Функция сканирования хэш-таблицы
void Object::scan(void(*f)(void*)) {
	for (int i = 0; i < this->size; i++) { // Проходим по всем элементам таблицы
		if (data[i] == NULL) // Если элемент пуст
			std::cout << "Элемент" << i << " пусто" << std::endl; // Выводим информацию о пустом элементе
		else if (data[i] == DEL) // Если элемент удален
			std::cout << "Элемент" << i << " удален" << std::endl; // Выводим информацию о удаленном элементе
		else {
			std::cout << "Элемент" << i << ", хеш: " << HashFunction(getKey(data[i]), size) << std::endl; // Выводим информацию о хеше
			f((this->data)[i]); // Вызываем функцию на элементе
		}
	}
}